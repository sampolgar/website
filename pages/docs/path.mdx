# Building in public

## Tech skills needed on git

- Typescript, Node.js, npm packages
- The Graph, Dune analytics, blockchain data APIs
- Bigquery, SQL, noSQL
- REST, GraphQL API
- AWS infrastructure, Docker, Github Action
- Solidity, Hardhat, Ethers.js, ZK
- Circom
- Rust

## Features

- fetching data on-chain for DID. e.g. if user has token assign badge
- building sdk
- building npm package

## 24/1

- highly recommended [Patrick free code camp 32 hr tutorial](https://www.youtube.com/watch?v=gyMwXuJrbJQ&t), let's start with that.

## 26/1

-[x] Write a contract that receives a minimum usd amount of eth and allows only the contract creator to withdraw. -[x] write from scratch w/o looking at solution

## 27/1

- [x] Write a contract that receives a minimum usd amount of eth and allows only the contract creator to withdraw
- [x] Think about what NPM packages I can build
- [x] Think about what tutorial I can build

### NPM package ideas

1. Simplified web3 library abstracting complex aspects of web3.js
2. NPM module for creating tokens, nft's, dapps, etc
3. NPM module for creating a gated community allowing sismo badge holders access
4. DID protocol with key requirement variables
5. create a token gated community website generator e.g. disqus

### Tutorial ideas

1. create a token gated community website
2. create a token gated community website generator

### Notes from today

- using `ethers` to create an encrypted json key from .env file [link](https://youtu.be/gyMwXuJrbJQ?t=28054)
- using `process.env.PRIVATE_KEY` with key in .env file or key sent in cmd execution e.g. `PRIVATE_KEY=MYPRIVATEKEY node index.js`

## 28/1

- [x] in ethers - write the storage contract
- [x] in ethers - write a contract that receives a minimum usd amount of eth and allows only the contract creator to withdraw

### Notes from today

- using `solc` to compile contracts from `.sol` to `.bin` + `.abi` to deploy with ethers `const factory = new ethers.ContractFactory(abi, binary, wallet)`
- needed specific version i.e. `yarn add solc@0.8.7-fixed`
- `yarn solcjs --bin --abi --include-path node_modules/ --base-path . -o . SimpleStorage.sol`
- add this to your scripts file e.g. scripts: `{"compile": "yarn...... SimpleStorage.sol"}`
- ethers, a `provider` is the network node, a `signer` is the private key of the wallet that deploys the contract, `contract` is the contract obj
- wasting time on the typescript tutorial, I'll change to javascript

### Hardhat

- if running `npx hardhat` doesn't return the hardhat creation prompts, check for parent `hardhat.config.js` file and remove it or run `npx hardhat --verbose`
- hardhat uses built in network by default => config in hardhat.config.js e.g. `module.exports = {defaultNetwork: "hardhat"}`
- or execute via cmd `yarn hardhat run scripts/deploy.js --network hardhat`
- `yarn hardhat` brings up tasks e.g. run or custom task
- `yarn hardhat console` brings up the js console to execute
- [open zeppelin ref](https://docs.openzeppelin.com/learn/deploying-and-interacting)

### chai

- execute specific tests with `yarn hardhat test --grep update-when-test`
- execute specific test by changing `it("should...` to `it.only("should...`
- tests use `beforeEach` to execute the contract creation before calling each `it`

```javascript
describe('SimpleStorage', function () {
  let SimpleStorageFactory, simpleStorage;
  beforeEach(async function () {
    simpleStorageFactory = await ethers.getContractFactory('SimpleStorage');
    simpleStorage = await simpleStorageFactory.deploy();
  });

  it('should start with a favorite number 0', async function () {
    const currentValue = await simpleStorage.retrieve();
    console.log(`current value is ${currentValue}`);
    const expectedValue = '0';
    assert.equal(currentValue.toString(), expectedValue);
  });

  it('should update when we store a number', async function () {
    const valUpdated = 5;
    const res = await simpleStorage.store(valUpdated);
    await res.wait(1);

    const valReturned = await simpleStorage.retrieve();
    console.log(` -------- ${valReturned}`);
    assert.equal(valUpdated, valReturned);
  });
});
```

## 29/1

## Notes from today

- really good github readme [link](https://github.com/othneildrew/Best-README-Template)
- hardhat typescript support requires `yarn add --dev @types/mocha @types/node @typechain/hardhat @typechain/ethers-v5 ts-node typechain typescript`
- Typescript needs correct typing on contracts, `typechain` and `typechain/hardhat` creates ts bindings automatically
- - `yarn hardhat typechain`

## 30/1

### complete the below w/o github copilot [link](https://youtu.be/gyMwXuJrbJQ?t=34728)

-[] create the SimpleStorage contract that stores a fav number, retreives the number, and stores an array of person structs (name, favnum)
-[] create a hardhat deployment script to deploy the SimpleStorage contract on Goerli
-[] verify it on Etherscan in the code
-[] interact with it
-[] Deploy the contract to hardhat network to view transactions on the console chain
-[] Deploy the contract to the Goerli testnet and verify it on Etherscan
-[] create a task to check the block number
-[] create tests for the contract
-[] check with coverage
-[] work with gas reporter in tests, check usd price with coinmarketcap api
-[] update to Typescript

#### round 1 completed - 5 hours

#### round 2 completed - 3 hours

### Notes

##### question

- Why does hre.run return `HardhatError: HH303: Unrecognized task verify: verify` but `run` doesn't.

```js
const verify = async (contractAddress, args) => {
  await hre.run('verify: verify', {});
};
```

##### question

-[x] how to understand what to include in a function, etc, from cmd linking in code

## Changing learning strategy

1. watch tutorial while following along and pausing (1.5 hr tutorial)
2. try to replicate

Proposed strategy

1. skip over whole tutorial quickly
2. watch tutorial in 10-15 minute segments
3. replicate each 10-15 segment before moving forwards
4. repeat

## 31/1

- [progress point](https://youtu.be/gyMwXuJrbJQ?t=38398)

1. change from deployment script to hardhat-deploy
2. copy the Aave format for helper-hardhat-config to enable different chain deployment.
3. update contract constructor and variables for different chain deployment
4. create a mock chainlink contract for hardhat network
5. use tags to deploy on different networks

updates to contract

- make the constructor dynamic for the pricefeed address (if different chains required) e.g.

```
AggregatorV3Interace public priceFeedAddress;
constructor(address _priceFeedAddress) { priceFeedAddress = AggregatorV3Interface(_priceFeedAddress); }
```

- test the mock deployment in hardhat with the mock chainlink contract
  `module.exports.tags = ["all", "mocks"]`
  `yarn hardhat deploy --tags mocks`

- code style in solidity [details](https://youtu.be/gyMwXuJrbJQ?t=39633)

## 1/2

### notes from today

- testing with ethereum waffle
- transaction test cases with `Arrange`, `Act`, `Assert` pattern
- debugging objects with javascript debugger
- console.log in solidity with hardhat console.log `import "hardhat/console.sol";`
- `process.exit(0))` to exit the script succesfully. `process.exit(1)` to exit with error

## Storage (gas optimization), [current link](https://youtu.be/gyMwXuJrbJQ?t=43817)

- `constant` and `immutable` variables are stored in bytecode (a pointer to )
- variables are stored in storage (a pointer to the blockchain)
- gas storage details found [here](https://github.com/crytic/evm-opcodes)
- prepend `s_` to variables appending to storage. e.g. `uint256 s_favNum;` (because storage is expensive)
- rather than having public `s_favNum` variable, create a public function to return the value. e.g. `function getFavNum() public view returns (uint256) { return s_favNum; }`
- rather than throwing an error with text e.g. `require(msg.sender == owner, "sorry, you can't do that");`, use an error code with `revert` =>

```solidity
error FundMe__NotOwner();
modifier errorOrNot(){
  if (msg.sender != i_owner) revert FundMe__NotOwner();
}
```

### competency level so far

| Higher Level Item | Item                         | Competency 1 - 5 | Fluency 1 - 5 |
| ----------------- | ---------------------------- | ---------------- | ------------- |
| Solidity          | Remix                        | 2                | 0             |
| Solidity          | Basic contract               | 1                | 0             |
| Solidity          | Storage / Memory / Types     | 1                | 0             |
| Solidity          | Best practice format/storage | 1                | 0             |
| Hardhat           | Hardhat / Ethers / Deploy    | 1                | 0             |
| Hardhat           | Chainlink USD                | 3                | 0             |
| Hardhat           | Chainlink Offline USD Mockup | 0                | 0             |
| Hardhat           | solc                         | 1                | 0             |
| Hardhat           | Coverage                     | 1                | 0             |
| Hardhat           | Scripts                      | 1                | 0             |
| Hardhat           | Tasks                        | 1                | 0             |
| Hardhat           | Etherscan                    | 1                | 0             |
| Hardhat           | Gas reporting                | 1                | 0             |
| Hardhat           | Ethereum Waffle / Chai       | 0.5              | 0             |
| Hardhat           | Dynamic chain support        | 1                | 0             |
| Hardhat           | Typechain                    | 1                | 0             |
| Hardhat           | TypeScript                   | 1                | 0             |

## 2/2

Before I continue with the tutorial, I will make a project to check my understanding and improve on the above.
To check my understanding, I'll create a community contract that allows users to make posts, like posts, and buy posts.

### draft 1

```solidity
contract CommunityMember {
  //make friend
  //make post w price
  //like post - can't like own post
  //buy post from someone
  //remove friend
}

contract ASingleCommunity {
    //add member
    //set membership payable
    //remove member
    //get list of members
    //
    //make group
    //make group admin
    //transfer group admin
    //
}

contract AllCommunities {
    //new member
    //remove member
    //get list of members
    //mapping member address and member name => mapping(address => string)
    //get list of friends - mapping address to name => mapping(address => mapping(address => ))

    //create community
    //get a community
    //get all communities
}
```

### draft 2 (simplify)

```solidity
contract CommunityMember {
  //make friend
  //remove friend
  //make post - add to post map, convert string to hex
  //like post - can't like own post, add to like map

  //------non essential
  //buy post from someone
}

contract AllCommunities {
    //new member
    //remove member
    //get list of members -- mapping member address and member name => mapping(address => string)
    //get list of a members friends -- mapping address to name => mapping(address => mapping(address => ))

    //------non essential
    //get a list of posts of 1 member - mapping address to posts => mapping(address => mapping(contentAddress => ))
    //get a list of post likes of 1 member - mapping address to likes => mapping(address => contentAddress)
}
```

- soft delete https://stackoverflow.com/questions/48515633/deleting-mapping-from-mapping-in-solidity

## 3/2

- initial values for data types https://ethereum.stackexchange.com/questions/40559/what-are-the-initial-zero-values-for-different-data-types-in-solidity

## 4/2

What's not working and why

## Types containing (nested) mappings can only be parameters or return variables of internal or library functions.

- the Member can't be stored in memory because it has a mapping
- mapping is not allowed in memory because map locations are stored at random in storage [details](https://ethereum.stackexchange.com/questions/107027/how-to-return-an-array-of-structs-that-has-mappings-nested-within-them)

```solidity
  struct Member {
      address memberAddress;
      string name;
      address[] friends;
      mapping(address => bool) friendsMap;
  }

  function getMemberByAddress(address _i) mustBeMember public view returns(Member memory){
        uint256 memberPosition = membersMap[_i];
        return membersArray[memberPosition];
  }
```

### Question

```solidity

    struct MemberMatch {
        uint256 arrayPos;
        bool memberExists;
    }
    mapping(address => MemberMatch) public amembersMap;

    or this

    mapping(address => uint256) internal membersMap;
    mapping(address => bool) internal memberExists;
```
